/**
 * @namespace proto
 * @typedef {import("@hashgraph/proto").TokenFreezeStatus} proto.TokenFreezeStatus
 * @typedef {import("@hashgraph/proto").TokenKycStatus} proto.TokenKycStatus
 * @typedef {import("@hashgraph/proto").ITokenInfo} proto.ITokenInfo
 * @typedef {import("@hashgraph/proto").ITimestamp} proto.ITimestamp
 * @typedef {import("@hashgraph/proto").ITokenID} proto.ITokenID
 * @typedef {import("@hashgraph/proto").IAccountID} proto.IAccountID
 * @typedef {import("@hashgraph/proto").IKey} proto.IKey
 */
/**
 * @typedef {import("@hashgraph/cryptography").Key} Key
 */
/**
 * Response when the client sends the node TokenGetInfoQuery.
 */
export default class TokenInfo {
    /**
     * @internal
     * @param {proto.ITokenInfo} info
     * @returns {TokenInfo}
     */
    static _fromProtobuf(info: proto.ITokenInfo): TokenInfo;
    /**
     * @private
     * @param {object} props
     * @param {TokenId} props.tokenId;
     * @param {string} props.name;
     * @param {string} props.symbol;
     * @param {number} props.decimals;
     * @param {Long} props.totalSupply;
     * @param {AccountId} props.treasury;
     * @param {Key} props.adminKey;
     * @param {Key} props.kycKey;
     * @param {Key} props.freezeKey;
     * @param {Key} props.wipeKey;
     * @param {Key} props.supplyKey;
     * @param {boolean | null} props.defaultFreezeStatus;
     * @param {boolean | null} props.defaultKycStatus;
     * @param {boolean} props.isDeleted;
     * @param {AccountId | null} props.autoRenewAccount;
     * @param {Long} props.autoRenewPeriod;
     * @param {Long} props.expirationTime;
     */
    private constructor();
    /**
     * ID of the token instance
     *
     * @readonly
     */
    readonly tokenId: TokenId;
    /**
     * The name of the token. It is a string of ASCII only characters
     *
     * @readonly
     */
    readonly name: string;
    /**
     * The symbol of the token. It is a UTF-8 capitalized alphabetical string
     *
     * @readonly
     */
    readonly symbol: string;
    /**
     * The number of decimal places a token is divisible by
     *
     * @readonly
     */
    readonly decimals: number;
    /**
     * The total supply of tokens that are currently in circulation
     *
     * @readonly
     */
    readonly totalSupply: Long.Long;
    /**
     * The ID of the account which is set as Treasury
     *
     * @readonly
     */
    readonly treasury: AccountId;
    /**
     * The key which can perform update/delete operations on the token. If empty, the token can be perceived as
     * immutable (not being able to be updated/deleted)
     *
     * @readonly
     */
    readonly adminKey: import("@hashgraph/cryptography").Key;
    /**
     * The key which can grant or revoke KYC of an account for the token's transactions. If empty, KYC is not required,
     * and KYC grant or revoke operations are not possible.
     *
     * @readonly
     */
    readonly kycKey: import("@hashgraph/cryptography").Key;
    /**
     * The key which can freeze or unfreeze an account for token transactions. If empty, freezing is not possible
     *
     * @readonly
     */
    readonly freezeKey: import("@hashgraph/cryptography").Key;
    /**
     * The key which can wipe token balance of an account. If empty, wipe is not possible
     *
     * @readonly
     */
    readonly wipeKey: import("@hashgraph/cryptography").Key;
    /**
     * The key which can change the supply of a token. The key is used to sign Token Mint/Burn operations
     *
     * @readonly
     */
    readonly supplyKey: import("@hashgraph/cryptography").Key;
    /**
     * The default Freeze status (not applicable = null, frozen = false, or unfrozen = true) of Hedera accounts relative to this token.
     * FreezeNotApplicable is returned if Token Freeze Key is empty. Frozen is returned if Token Freeze Key is set and
     * defaultFreeze is set to true. Unfrozen is returned if Token Freeze Key is set and defaultFreeze is set to false
     *      FreezeNotApplicable = null;
     *      Frozen = true;
     *      Unfrozen = false;
     *
     * @readonly
     */
    readonly defaultFreezeStatus: boolean | null;
    /**
     * The default KYC status (KycNotApplicable or Revoked) of Hedera accounts relative to this token. KycNotApplicable
     * is returned if KYC key is not set, otherwise Revoked
     *      KycNotApplicable = null;
     *      Granted = true;
     *      Revoked = false;
     *
     * @readonly
     */
    readonly defaultKycStatus: boolean | null;
    /**
     * Specifies whether the token was deleted or not
     *
     * @readonly
     */
    readonly isDeleted: boolean;
    /**
     * An account which will be automatically charged to renew the token's expiration, at autoRenewPeriod interval
     *
     * @readonly
     */
    readonly autoRenewAccount: AccountId | null;
    /**
     * The interval at which the auto-renew account will be charged to extend the token's expiry
     *
     * @readonly
     */
    readonly autoRenewPeriod: Long.Long;
    /**
     * The epoch second at which the token expire: will; if an auto-renew account and period are specified,
     * this is coerced to the current epoch second plus the autoRenewPeriod
     *
     * @readonly
     */
    readonly expirationTime: Long.Long;
    /**
     * @returns {proto.ITokenInfo}
     */
    _toProtobuf(): proto.ITokenInfo;
}
export type Key = import("@hashgraph/cryptography").Key;
import TokenId from "./TokenId.js";
import Long from "long";
import AccountId from "../account/AccountId.js";
declare namespace proto {
    type TokenFreezeStatus = import("@hashgraph/proto/lib/proto").proto.TokenFreezeStatus;
    type TokenKycStatus = import("@hashgraph/proto/lib/proto").proto.TokenKycStatus;
    type ITokenInfo = import("@hashgraph/proto/lib/proto").proto.ITokenInfo;
    type ITimestamp = import("@hashgraph/proto/lib/proto").proto.ITimestamp;
    type ITokenID = import("@hashgraph/proto/lib/proto").proto.ITokenID;
    type IAccountID = import("@hashgraph/proto/lib/proto").proto.IAccountID;
    type IKey = import("@hashgraph/proto/lib/proto").proto.IKey;
}
export {};
