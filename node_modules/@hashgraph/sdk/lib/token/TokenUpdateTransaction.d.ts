import { SingleTransactionBuilder } from "../TransactionBuilder";
import { Transaction } from "../generated/Transaction_pb";
import { TransactionResponse } from "../generated/TransactionResponse_pb";
import { grpc } from "@improbable-eng/grpc-web";
import { PublicKey } from "../crypto/PublicKey";
import { AccountIdLike } from "../account/AccountId";
import { TokenIdLike } from "./TokenId";
import UnaryMethodDefinition = grpc.UnaryMethodDefinition;
/**
 * Updates an already created Token. If no value is given for a field, that field is left unchanged. For an immutable
 * tokens (that is, a token created without an adminKey), only the expiry may be updated. Setting any other field in
 * that case will cause the transaction status to resolve to TOKEN_IS_IMMUTABlE.
 */
export declare class TokenUpdateTransaction extends SingleTransactionBuilder {
    private _body;
    constructor();
    /**
     * The Token to be updated
     */
    setTokenId(id: TokenIdLike): this;
    /**
     * The new Name of the Token. Must be a string of ASCII characters.
     */
    setName(name: string): this;
    /**
     * The new Symbol of the Token. Must be UTF-8 capitalized alphabetical string identifying the token.
     */
    setSymbol(symbol: string): this;
    /**
     * The new Treasury account of the Token. If the provided treasury account is not existing or deleted, the response
     * will be INVALID_TREASURY_ACCOUNT_FOR_TOKEN. If successful, the Token balance held in the previous
     * Treasury Account is transferred to the new one.
     */
    setTreasury(treasury: AccountIdLike): this;
    /**
     * The new Admin key of the Token. If Token is immutable, transaction will resolve to TOKEN_IS_IMMUTABlE.
     */
    setAdminKey(key: PublicKey): this;
    /**
     * The new KYC key of the Token. If Token does not have currently a KYC key, transaction will resolve to
     * TOKEN_HAS_NO_KYC_KEY.
     */
    setKycKey(key: PublicKey): this;
    /**
     * The new Freeze key of the Token. If the Token does not have currently a Freeze key, transaction will resolve to
     * TOKEN_HAS_NO_FREEZE_KEY.
     */
    setFreezeKey(key: PublicKey): this;
    /**
     * The new Wipe key of the Token. If the Token does not have currently a Wipe key, transaction will resolve to
     * TOKEN_HAS_NO_WIPE_KEY.
     */
    setWipeKey(key: PublicKey): this;
    /**
     * The new Supply key of the Token. If the Token does not have currently a Supply key, transaction will resolve to
     * TOKEN_HAS_NO_SUPPLY_KEY.
     */
    setSupplyKey(key: PublicKey): this;
    /**
     * The new expiry time of the token. Expiry can be updated even if admin key is not set. If the provided expiry is
     * earlier than the current token expiry, transaction wil resolve to INVALID_EXPIRATION_TIME
     */
    setExpirationTime(date: number | Date): this;
    /**
     * The new account which will be automatically charged to renew the token's expiration, at autoRenewPeriod interval.
     */
    setAutoRenewAccount(account: AccountIdLike): this;
    /**
     * The new interval at which the auto-renew account will be charged to extend the token's expiry.
     */
    setAutoRenewPeriod(seconds: number): this;
    protected get _method(): UnaryMethodDefinition<Transaction, TransactionResponse>;
    protected _doValidate(_: string[]): void;
}
