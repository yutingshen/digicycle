/**
 * @typedef {import("../channel/Channel.js").default} Channel
 * @typedef {import("../channel/MirrorChannel.js").default} MirrorChannel
 */
/**
 * @typedef {"mainnet" | "testnet" | "previewnet"} NetworkName
 */
/**
 * @typedef {object} Operator
 * @property {string | PrivateKey} privateKey
 * @property {string | AccountId} accountId
 */
/**
 * @typedef {object} ClientOperator
 * @property {PublicKey} publicKey
 * @property {AccountId} accountId
 * @property {(message: Uint8Array) => Promise<Uint8Array>} transactionSigner
 */
/**
 * @typedef {object} ClientConfiguration
 * @property {{[key: string]: (string | AccountId)} | NetworkName} network
 * @property {string[] | NetworkName | string} [mirrorNetwork]
 * @property {Operator} [operator]
 */
/**
 * @abstract
 * @template {Channel} ChannelT
 * @template {MirrorChannel} MirrorChannelT
 */
export default class Client<ChannelT extends import("../channel/Channel.js").default, MirrorChannelT extends import("../channel/MirrorChannel.js").default> {
    /**
     * @protected
     * @hideconstructor
     * @param {ClientConfiguration} [props]
     */
    protected constructor();
    /**
     * List of mirror network URLs.
     *
     * @private
     * @type {string[]}
     */
    private _mirrorNetwork;
    /**
     * Map of the mirror network URL to
     * its gRPC channel implementation.
     *
     * @private
     * @type {Map<string, MirrorChannelT>}
     */
    private _mirrorChannels;
    /**
     * @private
     * @type {number}
     */
    private _nextMirrorIndex;
    /**
     * Map of node account ID (as a string)
     * to the node URL.
     *
     * @private
     * @type {Map<string, string>}
     */
    private _network;
    /**
     * List of node account IDs.
     *
     * @private
     * @type {AccountId[]}
     */
    private _networkNodes;
    /**
     * @private
     * @type {number}
     */
    private _nextNetworkNodeIndex;
    /**
     * @private
     * @type {Map<AccountId, ChannelT>}
     */
    private _networkChannels;
    /**
     * @internal
     * @type {?ClientOperator}
     */
    _operator: ClientOperator | null;
    /**
     * @private
     * @type {Hbar}
     */
    private _maxTransactionFee;
    /**
     * @private
     * @type {Hbar}
     */
    private _maxQueryPayment;
    /**
     * @param {{[key: string]: (string | AccountId)}} network
     * @returns {void}
     */
    setNetwork(network: {
        [key: string]: string | AccountId;
    }): void;
    /**
     * @param {string[]} mirrorNetwork
     * @returns {void}
     */
    setMirrorNetwork(mirrorNetwork: string[]): void;
    /**
     * Set the account that will, by default, pay for transactions and queries built with this client.
     *
     * @param {AccountId | string} accountId
     * @param {PrivateKey | string} privateKey
     * @returns {this}
     */
    setOperator(accountId: AccountId | string, privateKey: PrivateKey | string): this;
    /**
     * Sets the account that will, by default, pay for transactions and queries built with
     * this client.
     *
     * @param {AccountId | string} accountId
     * @param {PublicKey | string} publicKey
     * @param {(message: Uint8Array) => Promise<Uint8Array>} transactionSigner
     * @returns {this}
     */
    setOperatorWith(accountId: AccountId | string, publicKey: PublicKey | string, transactionSigner: (message: Uint8Array) => Promise<Uint8Array>): this;
    /**
     * @returns {?AccountId}
     */
    get operatorAccountId(): AccountId | null;
    /**
     * @returns {?PublicKey}
     */
    get operatorPublicKey(): PublicKey | null;
    /**
     * @returns {Hbar}
     */
    get maxTransactionFee(): Hbar;
    /**
     * Set the maximum fee to be paid for transactions
     * executed by this client.
     *
     * @param {Hbar} maxTransactionFee
     * @returns {this}
     */
    setMaxTransactionFee(maxTransactionFee: Hbar): this;
    /**
     * @returns {Hbar}
     */
    get maxQueryPayment(): Hbar;
    /**
     * Set the maximum payment allowable for queries.
     *
     * @param {Hbar} maxQueryPayment
     * @returns {Client<ChannelT, MirrorChannelT>}
     */
    setMaxQueryPayment(maxQueryPayment: Hbar): Client<ChannelT, MirrorChannelT>;
    /**
     * @returns {void}
     */
    close(): void;
    /**
     * @private
     */
    private _closeNetworkChannels;
    /**
     * @private
     */
    private _closeMirrorNetworkChannels;
    /**
     * @internal
     * @returns {number}
     */
    _getNumberOfNodesForTransaction(): number;
    /**
     * @internal
     * @returns {AccountId}
     */
    _getNextNodeId(): AccountId;
    /**
     * @internal
     * @param {AccountId} nodeId
     * @returns {ChannelT}
     */
    _getNetworkChannel(nodeId: AccountId): ChannelT;
    /**
     * @internal
     * @returns {string}
     */
    _getNextMirrorAddress(): string;
    /**
     * @internal
     * @param {string} address
     * @returns {MirrorChannelT}
     */
    _getMirrorChannel(address: string): MirrorChannelT;
    /**
     * @abstract
     * @param {string} address
     * @returns {ChannelT}
     */
    _createNetworkChannel(address: string): ChannelT;
    /**
     * @abstract
     * @param {string} address
     * @returns {MirrorChannelT}
     */
    _createMirrorNetworkChannel(address: string): MirrorChannelT;
}
export type Channel = import("../channel/Channel.js").default;
export type MirrorChannel = import("../channel/MirrorChannel.js").default;
export type NetworkName = "mainnet" | "testnet" | "previewnet";
export type Operator = {
    privateKey: string | PrivateKey;
    accountId: string | AccountId;
};
export type ClientOperator = {
    publicKey: PublicKey;
    accountId: AccountId;
    transactionSigner: (message: Uint8Array) => Promise<Uint8Array>;
};
export type ClientConfiguration = {
    network: {
        [key: string]: string | AccountId;
    } | "mainnet" | "testnet" | "previewnet";
    mirrorNetwork?: string | string[] | undefined;
    operator?: Operator | undefined;
};
import AccountId from "../account/AccountId.js";
import { PrivateKey } from "@hashgraph/cryptography";
import { PublicKey } from "@hashgraph/cryptography";
import Hbar from "../Hbar.js";
