/**
 * @namespace proto
 * @typedef {import("@hashgraph/proto").ITimestamp} proto.ITimestamp
 * @typedef {import("@hashgraph/proto").IAccountID} proto.IAccountID
 * @typedef {import("@hashgraph/proto").ICryptoGetAccountBalanceResponse} proto.ICryptoGetAccountBalanceResponse
 * @typedef {import("@hashgraph/proto").IKey} proto.IKey
 */
/**
 * @typedef {import("@hashgraph/cryptography").Key} Key
 * @typedef {import("long")} Long
 */
export default class AccountBalance {
    /**
     * @internal
     * @param {proto.ICryptoGetAccountBalanceResponse} balance
     * @returns {AccountBalance}
     */
    static _fromProtobuf(balance: proto.ICryptoGetAccountBalanceResponse): AccountBalance;
    /**
     * @private
     * @param {object} props
     * @param {Hbar} props.hbars
     * @param {?TokenBalanceMap} props.tokens
     */
    private constructor();
    /**
     * The account ID for which this balancermation applies.
     *
     * @readonly
     */
    readonly hbars: Hbar;
    /** @readonly */
    readonly tokens: TokenBalanceMap | null;
    /**
     * @returns {proto.ICryptoGetAccountBalanceResponse}
     */
    _toProtobuf(): proto.ICryptoGetAccountBalanceResponse;
}
export type Key = import("@hashgraph/cryptography").Key;
export type Long = import("long").Long;
import Hbar from "../Hbar.js";
import TokenBalanceMap from "./TokenBalanceMap.js";
declare namespace proto {
    type ITimestamp = import("@hashgraph/proto/lib/proto").proto.ITimestamp;
    type IAccountID = import("@hashgraph/proto/lib/proto").proto.IAccountID;
    type ICryptoGetAccountBalanceResponse = import("@hashgraph/proto/lib/proto").proto.ICryptoGetAccountBalanceResponse;
    type IKey = import("@hashgraph/proto/lib/proto").proto.IKey;
}
export {};
