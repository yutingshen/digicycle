/**
 * @namespace proto
 * @typedef {import("@hashgraph/proto").ITransaction} proto.ITransaction
 * @typedef {import("@hashgraph/proto").ITransactionBody} proto.ITransactionBody
 * @typedef {import("@hashgraph/proto").ITransactionResponse} proto.ITransactionResponse
 * @typedef {import("@hashgraph/proto").ResponseCodeEnum} proto.ResponseCodeEnum
 * @typedef {import("@hashgraph/proto").TransactionBody} proto.TransactionBody
 */
/**
 * @typedef {import("@hashgraph/cryptography").PrivateKey} PrivateKey
 * @typedef {import("@hashgraph/cryptography").PublicKey} PublicKey
 * @typedef {import("../account/AccountId.js").default} AccountId
 * @typedef {import("../channel/Channel.js").default} Channel
 */
export const DEFAULT_AUTO_RENEW_PERIOD: Long.Long;
export const DEFAULT_RECORD_THRESHOLD: Hbar;
/**
 * @type {Map<proto.TransactionBody["data"], (body: proto.TransactionBody) => Transaction>}
 */
export const TRANSACTION_REGISTRY: Map<"contractCall" | "contractCreateInstance" | "contractUpdateInstance" | "contractDeleteInstance" | "cryptoAddLiveHash" | "cryptoCreateAccount" | "cryptoDelete" | "cryptoDeleteLiveHash" | "cryptoTransfer" | "cryptoUpdateAccount" | "fileAppend" | "fileCreate" | "fileDelete" | "fileUpdate" | "systemDelete" | "systemUndelete" | "freeze" | "consensusCreateTopic" | "consensusUpdateTopic" | "consensusDeleteTopic" | "consensusSubmitMessage" | "uncheckedSubmit" | "tokenCreation" | "tokenTransfers" | "tokenFreeze" | "tokenUnfreeze" | "tokenGrantKyc" | "tokenRevokeKyc" | "tokenDeletion" | "tokenUpdate" | "tokenMint" | "tokenBurn" | "tokenWipe" | "tokenAssociate" | "tokenDissociate" | undefined, (body: proto.TransactionBody) => Transaction>;
/**
 * Base class for all transactions that may be submitted to Hedera.
 *
 * @abstract
 * @augments {Executable<proto.ITransaction, proto.ITransactionResponse, TransactionResponse>}
 */
export default class Transaction extends Executable<import("@hashgraph/proto/lib/proto").proto.ITransaction, import("@hashgraph/proto/lib/proto").proto.ITransactionResponse, TransactionResponse> {
    /**
     * @param {Uint8Array} bytes
     * @returns {Transaction}
     */
    static fromBytes(bytes: Uint8Array): Transaction;
    /**
     * List of proto transactions that have been built from this SDK
     * transaction. Each one should share the same transaction ID.
     *
     * @private
     * @type {proto.ITransaction[]}
     */
    private _transactions;
    /**
     * Set of public keys (as string) who have signed this transaction so
     * we do not allow them to sign it again.
     *
     * @private
     * @type {Set<string>}
     */
    private _signerPublicKeys;
    /**
     * List of node account IDs for each transaction that has been
     * built.
     *
     * @private
     * @type {AccountId[]}
     */
    private _nodeIds;
    /**
     * The index of the next transaction to be executed.
     *
     * @private
     * @type {number}
     */
    private _nextTransactionIndex;
    /**
     * @private
     * @type {number}
     */
    private _transactionValidDuration;
    /**
     * @private
     * @type {?Hbar}
     */
    private _maxTransactionFee;
    /**
     * @private
     * @type {string}
     */
    private _transactionMemo;
    /**
     * @private
     * @type {?TransactionId}
     */
    private _transactionId;
    /**
     * @returns {?AccountId}
     */
    get nodeAccountId(): import("../account/AccountId.js").default | null;
    /**
     * @param {AccountId} nodeAccountId
     * @returns {this}
     */
    setNodeAccountId(nodeAccountId: AccountId): this;
    /**
     * @returns {number}
     */
    get transactionValidDuration(): number;
    /**
     * Sets the duration (in seconds) that this transaction is valid for.
     *
     * This is defaulted to 120 seconds (from the time its executed).
     *
     * @param {number} validDuration
     * @returns {this}
     */
    setTransactionValidDuration(validDuration: number): this;
    /**
     * @returns {?Hbar}
     */
    get maxTransactionFee(): Hbar | null;
    /**
     * Set the maximum transaction fee the operator (paying account)
     * is willing to pay.
     *
     * @param {Hbar} maxTransactionFee
     * @returns {this}
     */
    setMaxTransactionFee(maxTransactionFee: Hbar): this;
    /**
     * @returns {string}
     */
    get transactionMemo(): string;
    /**
     * Set a note or description to be recorded in the transaction
     * record (maximum length of 100 bytes).
     *
     * @param {string} transactionMemo
     * @returns {this}
     */
    setTransactionMemo(transactionMemo: string): this;
    /**
     * @returns {TransactionId}
     */
    get transactionId(): TransactionId;
    /**
     * Set the ID for this transaction.
     *
     * The transaction ID includes the operator's account ( the account paying the transaction
     * fee). If two transactions have the same transaction ID, they won't both have an effect. One
     * will complete normally and the other will fail with a duplicate transaction status.
     *
     * Normally, you should not use this method. Just before a transaction is executed, a
     * transaction ID will be generated from the operator on the client.
     *
     * @param {TransactionId} transactionId
     * @returns {this}
     */
    setTransactionId(transactionId: TransactionId): this;
    /**
     * @param {PrivateKey} privateKey
     * @returns {Promise<this>}
     */
    sign(privateKey: PrivateKey): Promise<this>;
    /**
     * @param {PublicKey} publicKey
     * @param {(message: Uint8Array) => Promise<Uint8Array>} transactionSigner
     * @returns {Promise<this>}
     */
    signWith(publicKey: PublicKey, transactionSigner: (message: Uint8Array) => Promise<Uint8Array>): Promise<this>;
    /**
     * @param {import("../client/Client.js").default<Channel, *>} client
     * @returns {Promise<this>}
     */
    signWithOperator(client: import("../client/Client.js").default<Channel, any>): Promise<this>;
    /**
     * Freeze this transaction from future modification to prepare for
     * signing or serialization.
     *
     * @returns {this}
     */
    freeze(): this;
    /**
     * Freeze this transaction from further modification to prepare for
     * signing or serialization.
     *
     * Will use the `Client`, if available, to generate a default Transaction ID and select 1/3
     * nodes to prepare this transaction for.
     *
     * @param {?import("../client/Client.js").default<Channel, *>} client
     * @returns {this}
     */
    freezeWith(client: import("../client/Client.js").default<Channel, any> | null): this;
    /**
     * @returns {Uint8Array}
     */
    toBytes(): Uint8Array;
    /**
     * @returns {Promise<Uint8Array>}
     */
    get transactionHash(): Promise<Uint8Array>;
    /**
     * @internal
     * @param {?AccountId} nodeId
     * @returns {proto.ITransaction}
     */
    _makeTransaction(nodeId: AccountId | null): proto.ITransaction;
    /**
     * @private
     * @param {?AccountId} nodeId
     * @returns {proto.ITransactionBody}
     */
    private _makeTransactionBody;
    /**
     * @abstract
     * @protected
     * @returns {NonNullable<proto.TransactionBody["data"]>}
     */
    protected _getTransactionDataCase(): NonNullable<proto.TransactionBody["data"]>;
    /**
     * @abstract
     * @protected
     * @returns {object}
     */
    protected _makeTransactionData(): object;
    /**
     * @protected
     * @returns {boolean}
     */
    protected _isFrozen(): boolean;
    /**
     * @protected
     */
    protected _requireNotFrozen(): void;
    /**
     * @private
     */
    private _requireExactlyOneFrozen;
}
export type PrivateKey = import("@hashgraph/cryptography").PrivateKey;
export type PublicKey = import("@hashgraph/cryptography").PublicKey;
export type AccountId = import("../account/AccountId.js").default;
export type Channel = import("../channel/Channel.js").default;
import Long from "long";
import Hbar from "../Hbar.js";
declare namespace proto {
    type ITransaction = import("@hashgraph/proto/lib/proto").proto.ITransaction;
    type ITransactionBody = import("@hashgraph/proto/lib/proto").proto.ITransactionBody;
    type ITransactionResponse = import("@hashgraph/proto/lib/proto").proto.ITransactionResponse;
    type ResponseCodeEnum = import("@hashgraph/proto/lib/proto").proto.ResponseCodeEnum;
    type TransactionBody = ProtoTransactionBody;
}
import TransactionResponse from "./TransactionResponse.js";
import Executable from "../Executable.js";
import TransactionId from "./TransactionId.js";
import { TransactionBody as ProtoTransactionBody } from "@hashgraph/proto";
export {};
