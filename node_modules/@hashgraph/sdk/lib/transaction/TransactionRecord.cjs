"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = void 0;

var _TransactionReceipt = _interopRequireDefault(require("./TransactionReceipt.cjs"));

var _TransactionId = _interopRequireDefault(require("./TransactionId.cjs"));

var _Timestamp = _interopRequireDefault(require("../Timestamp.cjs"));

var _Hbar = _interopRequireDefault(require("../Hbar.cjs"));

var _Transfer = _interopRequireDefault(require("../Transfer.cjs"));

var _ContractFunctionResult = _interopRequireDefault(require("../contract/ContractFunctionResult.cjs"));

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

/**
 * @namespace proto
 * @typedef {import("@hashgraph/proto").ITransactionRecord} proto.ITransactionRecord
 * @typedef {import("@hashgraph/proto").ITransactionReceipt} proto.ITransactionReceipt
 * @typedef {import("@hashgraph/proto").ITimestamp} proto.ITimestamp
 * @typedef {import("@hashgraph/proto").ITransactionID} proto.ITransactionID
 */

/**
 * Response when the client sends the node TransactionGetRecordResponse.
 */
class TransactionRecord {
  /**
   * @private
   * @param {object} props
   * @param {ContractFunctionResult} [props.contractFunctionResult]
   * @param {TransactionReceipt} props.receipt
   * @param {Uint8Array} props.transactionHash
   * @param {Timestamp} props.consensusTimestampstamp
   * @param {TransactionId} props.transactionId
   * @param {string} props.transactionMemo
   * @param {Hbar} props.transactionFee
   * @param {Transfer[]} props.transfers
   */
  constructor(props) {
    /**
     * The status (reach consensus, or failed, or is unknown) and the ID of
     * any new account/file/instance created.
     *
     * @readonly
     */
    this.receipt = props.receipt;
    /**
     * The hash of the Transaction that executed (not the hash of any Transaction that failed
     * for having a duplicate TransactionID).
     *
     * @readonly
     */

    this.transactionHash = props.transactionHash;
    /**
     * The consensus timestamp (or null if didn't reach consensus yet).
     *
     * @readonly
     */

    this.consensusTimestampstamp = props.consensusTimestampstamp;
    /**
     * The ID of the transaction this record represents.
     *
     * @readonly
     */

    this.transactionId = props.transactionId;
    /**
     * The memo that was submitted as part of the transaction (max 100 bytes).
     *
     * @readonly
     */

    this.transactionMemo = props.transactionMemo;
    /**
     * The actual transaction fee charged,
     * not the original transactionFee value from TransactionBody.
     *
     * @readonly
     */

    this.transactionFee = props.transactionFee;
    /**
     * All hbar transfers as a result of this transaction, such as fees, or transfers performed
     * by the transaction, or by a smart contract it calls, or by the creation of threshold
     * records that it triggers.
     *
     * @readonly
     */

    this.transfers = props.transfers;
    /**
     * Record of the value returned by the smart contract function or constructor.
     *
     * @readonly
     */

    this.contractFunctionResult = props.contractFunctionResult != null ? props.contractFunctionResult : null;
    Object.freeze(this);
  }
  /**
   * @internal
   * @param {proto.ITransactionRecord} record
   * @returns {TransactionRecord}
   */


  static _fromProtobuf(record) {
    const contractFunctionResult = record.contractCallResult != null ? _ContractFunctionResult.default._fromProtobuf(record.contractCallResult) : record.contractCreateResult != null ? _ContractFunctionResult.default._fromProtobuf(record.contractCreateResult) : undefined;
    return new TransactionRecord({
      receipt: _TransactionReceipt.default._fromProtobuf(
      /** @type {proto.ITransactionReceipt} */
      record.receipt),
      transactionHash: record.transactionHash != null ? record.transactionHash : new Uint8Array(),
      consensusTimestampstamp: _Timestamp.default._fromProtobuf(
      /** @type {proto.ITimestamp} */
      record.consensusTimestamp),
      transactionId: _TransactionId.default._fromProtobuf(
      /** @type {proto.ITransactionID} */
      record.transactionID),
      transactionMemo: record.memo != null ? record.memo : "",
      transactionFee: _Hbar.default.fromTinybars(record.transactionFee != null ? record.transactionFee : 0),
      transfers: (record.transferList != null ? record.transferList.accountAmounts != null ? record.transferList.accountAmounts : [] : []).map(aa => _Transfer.default._fromProtobuf(aa)),
      contractFunctionResult
    });
  }

}

exports.default = TransactionRecord;