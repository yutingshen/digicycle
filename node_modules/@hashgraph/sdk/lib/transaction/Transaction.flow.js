/**
 * Flowtype definitions for Transaction
 * Generated by Flowgen from a Typescript Definition
 * Flowgen v1.11.0
 */

/**
 * @namespace proto
 * @typedef {$PropertyType<$Exports<"@hashgraph/proto">, "ITransaction">} ITransaction
 * @typedef {$PropertyType<$Exports<"@hashgraph/proto">, "ITransactionBody">} ITransactionBody
 * @typedef {$PropertyType<$Exports<"@hashgraph/proto">, "ITransactionResponse">} ITransactionResponse
 * @typedef {$PropertyType<$Exports<"@hashgraph/proto">, "ResponseCodeEnum">} ResponseCodeEnum
 * @typedef {$PropertyType<$Exports<"@hashgraph/proto">, "TransactionBody">} TransactionBody
 */
/**
 * @typedef {$PropertyType<$Exports<"@hashgraph/cryptography">, "PrivateKey">} PrivateKey
 * @typedef {$PropertyType<$Exports<"@hashgraph/cryptography">, "PublicKey">} PublicKey
 * @typedef {$PropertyType<$Exports<"../account/AccountId.js">, "default">} AccountId
 * @typedef {$PropertyType<$Exports<"../channel/Channel.js">, "default">} Channel
 */
declare export var DEFAULT_AUTO_RENEW_PERIOD: Long.Long;
declare export var DEFAULT_RECORD_THRESHOLD: Hbar;
/**
 * @type {Map<$PropertyType<proto$TransactionBody, "data">, (body: proto$TransactionBody) => Transaction>}
 */
declare export var TRANSACTION_REGISTRY: Map<
  | "contractCall"
  | "contractCreateInstance"
  | "contractUpdateInstance"
  | "contractDeleteInstance"
  | "cryptoAddLiveHash"
  | "cryptoCreateAccount"
  | "cryptoDelete"
  | "cryptoDeleteLiveHash"
  | "cryptoTransfer"
  | "cryptoUpdateAccount"
  | "fileAppend"
  | "fileCreate"
  | "fileDelete"
  | "fileUpdate"
  | "systemDelete"
  | "systemUndelete"
  | "freeze"
  | "consensusCreateTopic"
  | "consensusUpdateTopic"
  | "consensusDeleteTopic"
  | "consensusSubmitMessage"
  | "uncheckedSubmit"
  | "tokenCreation"
  | "tokenTransfers"
  | "tokenFreeze"
  | "tokenUnfreeze"
  | "tokenGrantKyc"
  | "tokenRevokeKyc"
  | "tokenDeletion"
  | "tokenUpdate"
  | "tokenMint"
  | "tokenBurn"
  | "tokenWipe"
  | "tokenAssociate"
  | "tokenDissociate"
  | void,
  (body: proto$TransactionBody) => Transaction
>;
/**
 * Base class for all transactions that may be submitted to Hedera.
 * @abstract
 * @augments
 */
declare export default class Transaction
  mixins Executable<
      $Exports<"@hashgraph/proto/lib/proto">,
      $Exports<"@hashgraph/proto/lib/proto">,
      TransactionResponse
    > {
  /**
   * @param {Uint8Array} bytes
   * @returns {Transaction}
   */
  static fromBytes(bytes: Uint8Array): Transaction;

  /**
   * @returns {?AccountId}
   */
  nodeAccountId: $PropertyType<
    $Exports<"../account/AccountId.js">,
    "default"
  > | null;

  /**
   * @param {AccountId} nodeAccountId
   * @returns {this}
   */
  setNodeAccountId(nodeAccountId: AccountId): this;

  /**
   * @returns {number}
   */
  transactionValidDuration: number;

  /**
   * Sets the duration (in seconds) that this transaction is valid for.
   *
   * This is defaulted to 120 seconds (from the time its executed).
   * @param {number} validDuration
   * @returns {this}
   */
  setTransactionValidDuration(validDuration: number): this;

  /**
   * @returns {?Hbar}
   */
  maxTransactionFee: Hbar | null;

  /**
   * Set the maximum transaction fee the operator (paying account)
   * is willing to pay.
   * @param {Hbar} maxTransactionFee
   * @returns {this}
   */
  setMaxTransactionFee(maxTransactionFee: Hbar): this;

  /**
   * @returns {string}
   */
  transactionMemo: string;

  /**
   * Set a note or description to be recorded in the transaction
   * record (maximum length of 100 bytes).
   * @param {string} transactionMemo
   * @returns {this}
   */
  setTransactionMemo(transactionMemo: string): this;

  /**
   * @returns {TransactionId}
   */
  transactionId: TransactionId;

  /**
   * Set the ID for this transaction.
   *
   * The transaction ID includes the operator's account ( the account paying the transaction
   * fee). If two transactions have the same transaction ID, they won't both have an effect. One
   * will complete normally and the other will fail with a duplicate transaction status.
   *
   * Normally, you should not use this method. Just before a transaction is executed, a
   * transaction ID will be generated from the operator on the client.
   * @param {TransactionId} transactionId
   * @returns {this}
   */
  setTransactionId(transactionId: TransactionId): this;

  /**
   * @param {PrivateKey} privateKey
   * @returns {Promise<this>}
   */
  sign(privateKey: PrivateKey): Promise<this>;

  /**
   * @param {PublicKey} publicKey
   * @param {(message: Uint8Array) => Promise<Uint8Array>} transactionSigner
   * @returns {Promise<this>}
   */
  signWith(
    publicKey: PublicKey,
    transactionSigner: (message: Uint8Array) => Promise<Uint8Array>
  ): Promise<this>;

  /**
   * @param {$PropertyType<$Exports<"../client/Client.js">, "default">} client
   * @returns {Promise<this>}
   */
  signWithOperator(
    client: $PropertyType<$Exports<"../client/Client.js">, "default">
  ): Promise<this>;

  /**
   * Freeze this transaction from future modification to prepare for
   * signing or serialization.
   * @returns {this}
   */
  freeze(): this;

  /**
   * Freeze this transaction from further modification to prepare for
   * signing or serialization.
   *
   * Will use the `Client`, if available, to generate a default Transaction ID and select 1/3
   * nodes to prepare this transaction for.
   * @param {?$PropertyType<$Exports<"../client/Client.js">, "default">} client
   * @returns {this}
   */
  freezeWith(
    client: $PropertyType<$Exports<"../client/Client.js">, "default"> | null
  ): this;

  /**
   * @returns {Uint8Array}
   */
  toBytes(): Uint8Array;

  /**
   * @returns {Promise<Uint8Array>}
   */
  transactionHash: Promise<Uint8Array>;

  /**
   * @internal
   * @param {?AccountId} nodeId
   * @returns {proto$ITransaction}
   */
  _makeTransaction(nodeId: AccountId | null): proto$ITransaction;

  /**
   * @abstract
   * @protected
   * @returns {$NonMaybeType<$PropertyType<proto$TransactionBody, "data">>}
   */
  _getTransactionDataCase(): $NonMaybeType<
    $PropertyType<proto$TransactionBody, "data">
  >;

  /**
   * @abstract
   * @protected
   * @returns {{[key: string]: any}}
   */
  _makeTransactionData(): { [key: string]: any };

  /**
   * @protected
   * @returns {boolean}
   */
  _isFrozen(): boolean;

  /**
   * @protected
   */
  _requireNotFrozen(): void;
}
export type PrivateKey = $PropertyType<
  $Exports<"@hashgraph/cryptography">,
  "PrivateKey"
>;
export type PublicKey = $PropertyType<
  $Exports<"@hashgraph/cryptography">,
  "PublicKey"
>;
export type AccountId = $PropertyType<
  $Exports<"../account/AccountId.js">,
  "default"
>;
export type Channel = $PropertyType<
  $Exports<"../channel/Channel.js">,
  "default"
>;
import Long from "long";
import Hbar from "../Hbar.js";
declare type proto$ITransaction = $Exports<"@hashgraph/proto/lib/proto">;

declare type proto$ITransactionBody = $Exports<"@hashgraph/proto/lib/proto">;

declare type proto$ITransactionResponse = $Exports<
  "@hashgraph/proto/lib/proto"
>;

declare type proto$ResponseCodeEnum = $Exports<"@hashgraph/proto/lib/proto">;

declare type proto$TransactionBody = ProtoTransactionBody;
import TransactionResponse from "./TransactionResponse.js";
import Executable from "../Executable.js";
import TransactionId from "./TransactionId.js";
import { TransactionBody as ProtoTransactionBody } from "@hashgraph/proto";
declare export {};
