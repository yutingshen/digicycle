/**
 * Flowtype definitions for Query
 * Generated by Flowgen from a Typescript Definition
 * Flowgen v1.11.0
 */

/**
 * @param {TransactionId} paymentTransactionId
 * @param {AccountId} nodeId
 * @param {ClientOperator} operator
 * @param {Hbar} paymentAmount
 * @returns {Promise<proto$ITransaction>}
 */
declare export function _makePaymentTransaction(
  paymentTransactionId: TransactionId,
  nodeId: AccountId,
  operator: ClientOperator,
  paymentAmount: Hbar
): Promise<proto$ITransaction>;

/**
 * @typedef {$PropertyType<$Exports<"../channel/Channel.js">, "default">} Channel
 */
/**
 * @namespace proto
 * @typedef {$PropertyType<$Exports<"@hashgraph/proto">, "IQuery">} IQuery
 * @typedef {$PropertyType<$Exports<"@hashgraph/proto">, "IQueryHeader">} IQueryHeader
 * @typedef {$PropertyType<$Exports<"@hashgraph/proto">, "ITransaction">} ITransaction
 * @typedef {$PropertyType<$Exports<"@hashgraph/proto">, "IResponse">} IResponse
 * @typedef {$PropertyType<$Exports<"@hashgraph/proto">, "IResponseHeader">} IResponseHeader
 * @typedef {$PropertyType<$Exports<"@hashgraph/proto">, "ITransactionBody">} ITransactionBody
 * @typedef {$PropertyType<$Exports<"@hashgraph/proto">, "ResponseCodeEnum">} ResponseCodeEnum
 */
/**
 * @typedef {$PropertyType<$Exports<"../account/AccountId.js">, "default">} AccountId
 * @typedef {$PropertyType<$Exports<"../client/Client.js">, "ClientOperator">} ClientOperator
 */
/**
 * @type {Map<$PropertyType<ProtoQuery, "query">, (query: proto$IQuery) => Query<*>>}
 */
declare export var QUERY_REGISTRY: Map<
  | "getByKey"
  | "getBySolidityID"
  | "contractCallLocal"
  | "contractGetInfo"
  | "contractGetBytecode"
  | "ContractGetRecords"
  | "cryptogetAccountBalance"
  | "cryptoGetAccountRecords"
  | "cryptoGetInfo"
  | "cryptoGetLiveHash"
  | "cryptoGetProxyStakers"
  | "fileGetContents"
  | "fileGetInfo"
  | "transactionGetReceipt"
  | "transactionGetRecord"
  | "transactionGetFastRecord"
  | "consensusGetTopicInfo"
  | "networkGetVersionInfo"
  | "tokenGetInfo"
  | void,
  (query: proto$IQuery) => Query<any>
>;
/**
 * Base class for all queries that can be submitted to Hedera.
 * @abstract
 * @template
 * @augments
 */
declare export default class Query<OutputT>
  mixins Executable<
      $Exports<"@hashgraph/proto/lib/proto">,
      $Exports<"@hashgraph/proto/lib/proto">,
      OutputT
    > {
  /**
   * @template
   * @param {Uint8Array} bytes
   * @returns {Query<T>}
   */
  static fromBytes<T>(bytes: Uint8Array): Query<T>;

  /**
   * @type {?TransactionId}
   */
  _paymentTransactionId: TransactionId | null;

  /**
   * @type {proto$ITransaction[]}
   */
  _paymentTransactions: proto$ITransaction[];

  /**
   * @type {AccountId[]}
   */
  _paymentTransactionNodeIds: AccountId[];

  /**
   * @type {number}
   */
  _nextPaymentTransactionIndex: number;

  /**
   * @type {?Hbar}
   */
  _queryPayment: Hbar | null;

  /**
   * @type {?Hbar}
   */
  _maxQueryPayment: Hbar | null;

  /**
   * Explicit node account ID. If set, this query will be executed on this node and not chose a node
   * from the client's network.
   * @type {?AccountId}
   */
  _nodeId: AccountId | null;

  /**
   * @returns {Uint8Array}
   */
  toBytes(): Uint8Array;

  /**
   * @returns {?AccountId}
   */
  getNodeAccountId(): AccountId | null;

  /**
   * Set the account ID of the node that will be used to submit this
   * query to the network.
   *
   * This node must exist in the network on the client that is used to later
   * execute this query.
   * @param {AccountId} nodeId
   * @returns {this}
   */
  setNodeAccountId(nodeId: AccountId): this;

  /**
   * Set an explicit payment amount for this query.
   *
   * The client will submit exactly this amount for the payment of this query. Hedera
   * will not return any remainder.
   * @param {Hbar} queryPayment
   * @returns {this}
   */
  setQueryPayment(queryPayment: Hbar): this;

  /**
   * Set the maximum payment allowable for this query.
   * @param {Hbar} maxQueryPayment
   * @returns {this}
   */
  setMaxQueryPayment(maxQueryPayment: Hbar): this;

  /**
   * @param {$PropertyType<$Exports<"../client/Client.js">, "default">} client
   * @returns {Promise<Hbar>}
   */
  getCost(
    client: $PropertyType<$Exports<"../client/Client.js">, "default">
  ): Promise<Hbar>;

  /**
   * @protected
   * @returns {boolean}
   */
  _isPaymentRequired(): boolean;

  /**
   * @override
   * @template
   * @template
   * @param {$PropertyType<$Exports<"../client/Client.js">, "default">} client
   * @returns {void}
   */
  _setPaymentNodeIds<ChannelT, MirrorChannelT>(
    client: $PropertyType<$Exports<"../client/Client.js">, "default">
  ): void;

  /**
   * @abstract
   * @internal
   * @param {proto$IResponse} response
   * @returns {proto$IResponseHeader}
   */
  _mapResponseHeader(response: proto$IResponse): proto$IResponseHeader;

  /**
   * @protected
   * @returns {proto$IQueryHeader}
   */
  _makeRequestHeader(): proto$IQueryHeader;

  /**
   * @abstract
   * @internal
   * @param {proto$IQueryHeader} header
   * @returns {proto$IQuery}
   */
  _onMakeRequest(header: proto$IQueryHeader): proto$IQuery;
}
/**
 * @type {((query: Query<*>) => $PropertyType<$Exports<"./CostQuery.js">, "default">)[]}
 */
declare export var COST_QUERY: ((
  query: Query<any>
) => $PropertyType<$Exports<"./CostQuery.js">, "default">)[];
export type Channel = $PropertyType<
  $Exports<"../channel/Channel.js">,
  "default"
>;
export type AccountId = $PropertyType<
  $Exports<"../account/AccountId.js">,
  "default"
>;
export type ClientOperator = {
  publicKey: $PropertyType<$Exports<"@hashgraph/cryptography">, "PublicKey">,
  accountId: $PropertyType<$Exports<"../account/AccountId.js">, "default">,
  transactionSigner: (message: Uint8Array) => Promise<Uint8Array>,
  ...
};
import TransactionId from "../transaction/TransactionId.js";
import Hbar from "../Hbar.js";
declare type proto$IQuery = $Exports<"@hashgraph/proto/lib/proto">;

declare type proto$IQueryHeader = $Exports<"@hashgraph/proto/lib/proto">;

declare type proto$ITransaction = $Exports<"@hashgraph/proto/lib/proto">;

declare type proto$IResponse = $Exports<"@hashgraph/proto/lib/proto">;

declare type proto$IResponseHeader = $Exports<"@hashgraph/proto/lib/proto">;

declare type proto$ITransactionBody = $Exports<"@hashgraph/proto/lib/proto">;

declare type proto$ResponseCodeEnum = $Exports<"@hashgraph/proto/lib/proto">;
import { Query as ProtoQuery } from "@hashgraph/proto";
import Executable from "../Executable.js";
declare export {};
