/**
 * @param {TransactionId} paymentTransactionId
 * @param {AccountId} nodeId
 * @param {ClientOperator} operator
 * @param {Hbar} paymentAmount
 * @returns {Promise<proto.ITransaction>}
 */
export function _makePaymentTransaction(paymentTransactionId: TransactionId, nodeId: AccountId, operator: ClientOperator, paymentAmount: Hbar): Promise<proto.ITransaction>;
/**
 * @typedef {import("../channel/Channel.js").default} Channel
 */
/**
 * @namespace proto
 * @typedef {import("@hashgraph/proto").IQuery} proto.IQuery
 * @typedef {import("@hashgraph/proto").IQueryHeader} proto.IQueryHeader
 * @typedef {import("@hashgraph/proto").ITransaction} proto.ITransaction
 * @typedef {import("@hashgraph/proto").IResponse} proto.IResponse
 * @typedef {import("@hashgraph/proto").IResponseHeader} proto.IResponseHeader
 * @typedef {import("@hashgraph/proto").ITransactionBody} proto.ITransactionBody
 * @typedef {import("@hashgraph/proto").ResponseCodeEnum} proto.ResponseCodeEnum
 */
/**
 * @typedef {import("../account/AccountId.js").default} AccountId
 * @typedef {import("../client/Client.js").ClientOperator} ClientOperator
 */
/**
 * @type {Map<ProtoQuery["query"], (query: proto.IQuery) => Query<*>>}
 */
export const QUERY_REGISTRY: Map<"getByKey" | "getBySolidityID" | "contractCallLocal" | "contractGetInfo" | "contractGetBytecode" | "ContractGetRecords" | "cryptogetAccountBalance" | "cryptoGetAccountRecords" | "cryptoGetInfo" | "cryptoGetLiveHash" | "cryptoGetProxyStakers" | "fileGetContents" | "fileGetInfo" | "transactionGetReceipt" | "transactionGetRecord" | "transactionGetFastRecord" | "consensusGetTopicInfo" | "networkGetVersionInfo" | "tokenGetInfo" | undefined, (query: proto.IQuery) => Query<any>>;
/**
 * Base class for all queries that can be submitted to Hedera.
 *
 * @abstract
 * @template OutputT
 * @augments {Executable<proto.IQuery, proto.IResponse, OutputT>}
 */
export default class Query<OutputT> extends Executable<import("@hashgraph/proto/lib/proto").proto.IQuery, import("@hashgraph/proto/lib/proto").proto.IResponse, OutputT> {
    /**
     * @template T
     * @param {Uint8Array} bytes
     * @returns {Query<T>}
     */
    static fromBytes<T>(bytes: Uint8Array): Query<T>;
    /** @type {?TransactionId} */
    _paymentTransactionId: TransactionId | null;
    /** @type {proto.ITransaction[]} */
    _paymentTransactions: proto.ITransaction[];
    /** @type {AccountId[]} */
    _paymentTransactionNodeIds: AccountId[];
    /** @type {number} */
    _nextPaymentTransactionIndex: number;
    /** @type {?Hbar} */
    _queryPayment: Hbar | null;
    /** @type {?Hbar} */
    _maxQueryPayment: Hbar | null;
    /**
     * Explicit node account ID. If set, this query will be executed on this node and not chose a node
     * from the client's network.
     *
     * @type {?AccountId}
     */
    _nodeId: AccountId | null;
    /**
     * @returns {Uint8Array}
     */
    toBytes(): Uint8Array;
    /**
     * @returns {?AccountId}
     */
    getNodeAccountId(): AccountId | null;
    /**
     * Set the account ID of the node that will be used to submit this
     * query to the network.
     *
     * This node must exist in the network on the client that is used to later
     * execute this query.
     *
     * @param {AccountId} nodeId
     * @returns {this}
     */
    setNodeAccountId(nodeId: AccountId): this;
    /**
     * Set an explicit payment amount for this query.
     *
     * The client will submit exactly this amount for the payment of this query. Hedera
     * will not return any remainder.
     *
     * @param {Hbar} queryPayment
     * @returns {this}
     */
    setQueryPayment(queryPayment: Hbar): this;
    /**
     * Set the maximum payment allowable for this query.
     *
     * @param {Hbar} maxQueryPayment
     * @returns {this}
     */
    setMaxQueryPayment(maxQueryPayment: Hbar): this;
    /**
     * @param {import("../client/Client.js").default<Channel, *>} client
     * @returns {Promise<Hbar>}
     */
    getCost(client: import("../client/Client.js").default<Channel, any>): Promise<Hbar>;
    /**
     * @protected
     * @returns {boolean}
     */
    protected _isPaymentRequired(): boolean;
    /**
     * @override
     * @template ChannelT
     * @template MirrorChannelT
     * @param {import("../client/Client.js").default<ChannelT, MirrorChannelT>} client
     * @returns {void}
     */
    _setPaymentNodeIds<ChannelT, MirrorChannelT>(client: import("../client/Client.js").default<ChannelT, MirrorChannelT>): void;
    /**
     * @abstract
     * @internal
     * @param {proto.IResponse} response
     * @returns {proto.IResponseHeader}
     */
    _mapResponseHeader(response: proto.IResponse): proto.IResponseHeader;
    /**
     * @protected
     * @returns {proto.IQueryHeader}
     */
    protected _makeRequestHeader(): proto.IQueryHeader;
    /**
     * @abstract
     * @internal
     * @param {proto.IQueryHeader} header
     * @returns {proto.IQuery}
     */
    _onMakeRequest(header: proto.IQueryHeader): proto.IQuery;
}
/**
 * @type {((query: Query<*>) => import("./CostQuery.js").default<*>)[]}
 */
export const COST_QUERY: ((query: Query<any>) => import("./CostQuery.js").default<any>)[];
export type Channel = import("../channel/Channel.js").default;
export type AccountId = import("../account/AccountId.js").default;
export type ClientOperator = {
    publicKey: import("@hashgraph/cryptography").PublicKey;
    accountId: import("../account/AccountId.js").default;
    transactionSigner: (message: Uint8Array) => Promise<Uint8Array>;
};
import TransactionId from "../transaction/TransactionId.js";
import Hbar from "../Hbar.js";
declare namespace proto {
    type IQuery = import("@hashgraph/proto/lib/proto").proto.IQuery;
    type IQueryHeader = import("@hashgraph/proto/lib/proto").proto.IQueryHeader;
    type ITransaction = import("@hashgraph/proto/lib/proto").proto.ITransaction;
    type IResponse = import("@hashgraph/proto/lib/proto").proto.IResponse;
    type IResponseHeader = import("@hashgraph/proto/lib/proto").proto.IResponseHeader;
    type ITransactionBody = import("@hashgraph/proto/lib/proto").proto.ITransactionBody;
    type ResponseCodeEnum = import("@hashgraph/proto/lib/proto").proto.ResponseCodeEnum;
}
import { Query as ProtoQuery } from "@hashgraph/proto";
import Executable from "../Executable.js";
export {};
